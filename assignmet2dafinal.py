# -*- coding: utf-8 -*-
"""Assignmet2DAFinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SHQAQxqQFj-Tqcs1T8r7z_F1Hj4bdZ2n
"""

import pandas as pd
import numpy as np
from numpy import pi as pi
import datetime
import matplotlib.pyplot as plt
import scipy.optimize
import seaborn as sns
from scipy.optimize import minimize, differential_evolution

class Datapreprocessing:
    def __init__(self, file_path):
        self.file_path = file_path
        self.df = pd.read_csv(self.file_path)

    def calculate_time_deltas(self):
        opposition_times = []
        for index, row in self.df.iterrows():
            opposition_time = datetime.datetime(
                year=int(row['Year']),
                month=int(row['Month']),
                day=int(row['Day']),
                hour=int(row['Hour']),
                minute=int(row['Minute']))
            opposition_times.append(opposition_time)

        initial_time = opposition_times[0]
        self.df['days_passed'] = [(time - initial_time).total_seconds() / (3600 * 24) for time in opposition_times]

    def calculate_longitude_degrees(self):
        self.df['longitude_in_degrees'] = (self.df['ZodiacIndex'] * 30 + self.df['Degree'] + self.df['Minute.1'] / 60 + self.df['Second'] / 3600)

    def process_data(self):
        self.calculate_time_deltas()
        self.calculate_longitude_degrees()
        self.df = self.df[['days_passed', 'longitude_in_degrees']]

        return self.df['longitude_in_degrees'].to_numpy(), self.df['days_passed'].to_numpy()

# Load the dataset
mars_orbit_data = Datapreprocessing('https://raw.githubusercontent.com/Arjun-08/Mars-orbit/main/01_data_mars_opposition_updated.csv')

longitude_vals, time_vals = mars_orbit_data.process_data()

print("Time Vals:", time_vals)
print("Longitude Vals:", longitude_vals)

class OrbitModel:
    def __init__(self, c_val, r_val, eccentricity, angle_offset, z_val, angular_speed, time_data=time_vals, longitude_data=longitude_vals):
        self.cx_val = np.cos(c_val)
        self.cy_val = np.sin(c_val)
        self.eccentricity = eccentricity
        self.ex = eccentricity * np.cos(angle_offset)
        self.ey = eccentricity * np.sin(angle_offset)
        self.z_val = (angular_speed * time_data + z_val) % (2 * np.pi)
        self.r_val = r_val
        self.longitude_data = np.radians(longitude_data)
        self.error_list = None

    def calculate_error(self):
        const_term = self.ey - self.ex * np.tan(self.z_val) - self.cy_val
        a = 1 + np.square(np.tan(self.z_val))
        b = (2 * np.tan(self.z_val) * const_term - 2 * self.cx_val)
        c = np.square(const_term) + np.square(self.cx_val) - np.square(self.r_val)

        discriminant = np.sqrt(np.clip(b**2 - 4 * a * c, 0, None))
        x1 = (-b + discriminant) / (2 * a)
        x2 = (-b - discriminant) / (2 * a)

        y1 = self.ey + (x1 - self.ex) * np.tan(self.z_val)
        y2 = self.ey + (x2 - self.ex) * np.tan(self.z_val)

        angle1 = np.arctan2(y1, x1)
        angle2 = np.arctan2(y2, x2)
        actual_angles = self.longitude_data

        abs_error1 = np.abs(angle1 - actual_angles)
        abs_error2 = np.abs(angle2 - actual_angles)

        abs_error1 = np.where(abs_error1 > np.pi, 2 * np.pi - abs_error1, abs_error1)
        abs_error2 = np.where(abs_error2 > np.pi, 2 * np.pi - abs_error2, abs_error2)

        self.error_list = np.minimum(abs_error1, abs_error2)

    def get_errors(self):
        if self.error_list is not None:
            return self.error_list
        else:
            raise ValueError("Error list is not computed. Call `calculate_error()` first.")

    def fit(self):
        self.calculate_error()
        return np.max(np.abs(self.error_list))

    def plot(self):
        fig, ax = plt.subplots()

        ax.plot([0, self.ex], [0, self.ey], 'r-')

        xs = 10 * np.cos(self.z_val) + self.ex
        ys = 10 * np.sin(self.z_val) + self.ey
        for i in range(len(self.z_val)):
            ax.plot([self.ex, xs[i]], [self.ey, ys[i]], 'g--')

        circle = plt.Circle((self.cx_val, self.cy_val), self.r_val, color='b', fill=False)
        ax.add_patch(circle)

        ox = 10 * np.cos(self.longitude_data)
        oy = 10 * np.sin(self.longitude_data)
        for j in range(len(self.longitude_data)):
            ax.plot([0, ox[j]], [0, oy[j]], 'k-')

        ax.set_aspect('equal', 'box')
        plt.show()

class VariableOptimizer:
    def __init__(self, parameter, initial_value, model_args, value_bounds, model_class=OrbitModel):
        self.value_bounds = value_bounds
        self.parameter = parameter
        self.initial_value = initial_value
        self.model_args = model_args

        self.model_class = model_class

    def target_function(self, current_value, param_name):
                parameter_dict = {
                    'c': self.model_args.get('c', None),
                    'r': self.model_args.get('r', None),
                    'e1': self.model_args.get('e1', None),
                    'e2': self.model_args.get('e2', None),
                    'z': self.model_args.get('z', None),
                    's': self.model_args.get('s', None),
                }
                parameter_dict.update({param_name: current_value})

                c_val = parameter_dict.get('c', self.model_args['c'])
                r_val = parameter_dict.get('r', self.model_args['r'])
                e1_val = parameter_dict.get('e1', self.model_args['e1'])
                e2_val = parameter_dict.get('e2', self.model_args['e2'])
                z_val = parameter_dict.get('z', self.model_args['z'])
                s_val = parameter_dict.get('s', self.model_args['s'])

                return self.model_class(c_val, r_val, e1_val, e2_val, z_val, s_val).fit()


    def optimize(self):
        optimization_result = minimize(self.target_function,
                                       x0=np.array([self.initial_value]),
                                       args=self.parameter,
                                       method='Nelder-Mead',
                                       bounds=[self.value_bounds],
                                       options={
                                           'maxiter': 10000,
                                           'adaptive': True,
                                           'fatol': 1e-9
                                       })
        return optimization_result.x

class OptimizerEngine:
    def __init__(self, r_val, s_val, init_params, time_data=time_vals, opposition_data=longitude_vals, model_class=OrbitModel):
        self.r_val = r_val
        self.s_val = s_val
        self.time_data = time_data
        self.opposition_data = opposition_data
        self.model_class = model_class
        self.init_params = init_params

    def target_function(self, parameters):
        c_val = parameters[0]
        e1_val = parameters[1]
        e2_val = parameters[2]
        z_val = parameters[3]
        return self.model_class(c_val, self.r_val, e1_val, e2_val, z_val, self.s_val, self.time_data, self.opposition_data).fit()

    def execute_optimization(self):
        result = minimize(self.target_function,
                          x0=self.init_params,
                          method='Nelder-Mead',
                          bounds=((0, None), (0, 0.8 * self.r_val), (0, None), (0, None)),
                          options={'maxiter': 1000})
        optimized_args = result.x
        return optimized_args

    def execute_brute_force(self):
        brute_force_ranges = (slice(-pi, pi, 0.2), slice(0, self.r_val, 1), slice(-pi, pi, 0.2), slice(-pi, pi, 0.2))
        brute_result = scipy.optimize.brute(self.target_function, ranges=brute_force_ranges, finish=scipy.optimize.fmin)
        return brute_result, self.target_function(brute_result)

"""Question1"""

def MarsEquantModel(c, r, e1, e2, z, s, times, oppositions):
    model_instance = OrbitModel(c, r, e1, e2, z, s)
    max_err_value = model_instance.fit()
    error_series = model_instance.get_errors()

    return error_series, max_err_value

def optimize_params(times, oppositions):
    bounds = [
        (0.0, 10.0),
        (0.0, 10.0),
        (0.0, 10.0),
        (0.0, 10.0),
        (0.0, 360.0),
        (0.0, 0.01)
    ]

    def optimization_function(params):
        c, r, e1, e2, z, s = params
        errors, maxError = MarsEquantModel(c, r, e1, e2, z, s, times, oppositions)
        return maxError

    result = differential_evolution(optimization_function, bounds, tol=1e-6)

    optimal_params = result.x
    final_errors, final_max_error = MarsEquantModel(*optimal_params, times, oppositions)

    return optimal_params, final_errors, final_max_error

if __name__ == "__main__":
    optimal_params, errors, max_error = optimize_params(time_vals, longitude_vals)

    print(f'Optimal parameters: {optimal_params}')

params = {
    'c' : optimal_params[0], 'r': optimal_params[1], 'e1': optimal_params[2], 'e2': optimal_params[3], 'z': optimal_params[4], 's': optimal_params[5]
}

params

# Question 01
print('QUESTION 01')
errors, maxError = MarsEquantModel(optimal_params[0], optimal_params[1], optimal_params[2], optimal_params[3], optimal_params[4], optimal_params[5],time_vals, longitude_vals)
print(f'Errors: {", ".join(f"{e:.7f}" for e in errors)}')
print(f'MaxError in degrees: {maxError:.7f}')
max_error_radians = maxError * np.pi / 180
print(f'MaxError in radians: {max_error_radians:.7f}')

max_error_mins = maxError * 60
print(f'MaxError in mins: {max_error_mins:.7f}')

opti_args_q2= params.copy()

orbit_model = OrbitModel(
    c_val=opti_args_q2['c'],
    r_val=opti_args_q2['r'],
    eccentricity=opti_args_q2['e1'],
    angle_offset=opti_args_q2['e2'],
    z_val= opti_args_q2['z'],
    angular_speed=opti_args_q2['s'],
    time_data=time_vals,
    longitude_data=longitude_vals
)

orbit_model.plot()

"""Question 2:"""

def bestOrbitInnerParams(r, s, opti_args, times=time_vals, oppositions=longitude_vals):
    counter = 25
    opti_args['s'] = s
    opti_args['r'] = r

    def run_exhaustive(r_new, s_new):
        opti_args['r'] = r_new
        opti_args['s'] = s_new
        search_var = ['e1', 'e2', 'z', 'c']
        bounds = [(1, 0.8 * opti_args['r']), (0, 2 * pi), (0, 2 * pi), (0, 2 * pi)]

        for i in 2 * [3, 2, 1, 0]:
            var = search_var[i]
            question2 = VariableOptimizer(parameter=var, initial_value=opti_args[var], model_args=opti_args, value_bounds=bounds[i], model_class=OrbitModel)
            opti_args[var] = question2.optimize()[0]

        init = [ opti_args['c'], opti_args['e1'], opti_args['e2'], opti_args['z']]
        q2 = OptimizerEngine(r_val=opti_args['r'], s_val=opti_args['s'], init_params=init,time_data=time_vals, opposition_data=longitude_vals, model_class=OrbitModel)
        opti_args['c'], opti_args['e1'], opti_args['e2'], opti_args['z'] = q2.execute_optimization()


    for temp_i in range(counter):
        run_exhaustive(r, s)

    q2_model = OrbitModel(opti_args['c'], opti_args['r'], opti_args['e1'], opti_args['e2'], opti_args['z'], opti_args['s'])
    max_error = q2_model.fit()
    q2_model.get_errors()

    return opti_args['c'], opti_args['e1'], opti_args['e2'], opti_args['z'], q2_model.get_errors(), max_error

# Question 2 - Optimized Orbit Parameters
print('\nQUESTION 02')

radius_val = 8.80309438592382
angular_speed = 0.009146961946971288

c_val, e1_val, e2_val, z_val, orbit_errors, max_error = bestOrbitInnerParams(radius_val, angular_speed, opti_args_q2, time_vals, longitude_vals)

print(f'Optimized c: {c_val}, e1: {e1_val}, e2: {e2_val}, z: {z_val}')
print(f'Orbit Errors: {orbit_errors}')
print(f'Maximum Error: {max_error}')

max_error_radians2 = max_error * np.pi / 180
print(f'MaxError in radians: {max_error_radians2}')

opt_args_q3 = {'c': c_val, 'e1': e1_val, 'e2': e2_val, 'z': z_val, 'r': radius_val, 's': angular_speed}

opt_args_q3

# Question 3 - Optimizing Parameter S
def optimize_s(s_value):
    c_opt, e1_opt, e2_opt, z_opt, calculated_errors, max_err_value = bestOrbitInnerParams(opt_args_q3['r'], s_value, opti_args=opt_args_q3)
    return max_err_value


def optimizeS(radius_val, params=opt_args_q3, time_data=time_vals, opposition_data=longitude_vals):
    opt_args_q3['r'] = radius_val
    result = minimize(optimize_s, x0=np.array(opt_args_q3['s']), method='Nelder-Mead', tol=1e-16, bounds=[(0.97 * 0.00914694657579844, 1.03 * 0.00914694657579844)])

    opt_args_q3['s'] = result.x[0]

    errors, max_error = MarsEquantModel(opt_args_q3['c'], opt_args_q3['r'], opt_args_q3['e1'], opt_args_q3['e2'], opt_args_q3['z'], opt_args_q3['s'], time_vals, longitude_vals)

    return opt_args_q3['s'], errors, max_error

# Question 03 - Find Optimal 's'
print('\nQUESTION 03')

opt_s, opt_errors, max_err_s = optimizeS(radius_val=radius_val)

print(f'Optimal s: {opt_s}')
print(f'Error values: {opt_errors}')
print(f'Maximum Error: {max_err_s}')
print(opt_args_q3)

max_error_radians3 = max_err_s * np.pi / 180
print(f'MaxError in radians: {max_error_radians3}')

# Prepare arguments for the next optimization
q4_params = opt_args_q3.copy()

def optimize_radius(radius_value):
    c_val, e1_val, e2_val, z_val, errors, max_err = bestOrbitInnerParams(radius_value, q4_params['s'], opti_args=q4_params)
    return max_err


def optimizeR(angular_speed, params=q4_params, time_data=time_vals, opposition_data=longitude_vals):
    q4_params['s'] = angular_speed
    result = minimize(optimize_radius, x0=np.array([q4_params['r']]), method='Nelder-Mead', tol=1e-16)

    q4_params['r'] = result.x[0]
    calculated_errors, max_err_value = MarsEquantModel(q4_params['c'], q4_params['r'], q4_params['e1'], q4_params['e2'], q4_params['z'], q4_params['s'], time_data, opposition_data)

    return q4_params['r'], calculated_errors, max_err_value

# Question 04 - Find Optimal 'r'
print('\nQUESTION 04')

opt_r, opt_errors_r, max_err_r = optimizeR(q4_params['s'])

q4_params['r'] = opt_r

print(f'Optimal radius r: {opt_r}')
print(f'Error values: {opt_errors_r}')
print(f'Maximum Error: {max_err_r}')
print(q4_params)

max_error_radians4 = max_err_r * np.pi / 180
print(f'MaxError in radians: {max_error_radians4}')

"""Question 05"""

q5_params = q4_params.copy()

def bestMarsOrbitParams(time_vals, opposition_vals, initial_r=8.18212891, initial_s=0.00914694657579844):
    optimal_s, errors_s, max_error_s = optimizeS(initial_r)
    optimal_r, errors_r, max_error_r = optimizeR(optimal_s)

    best_c, best_e1, best_e2, best_z, final_errors, final_max_error = bestOrbitInnerParams(r=optimal_r, s=optimal_s, opti_args=q5_params, times=time_vals, oppositions=opposition_vals)

    return best_c, best_e1, best_e2, best_z, optimal_r, optimal_s, final_errors, final_max_error

print('\nQUESTION 05')
best_c, best_e1, best_e2, best_z, best_r, best_s, angular_errors, max_angular_error = bestMarsOrbitParams(time_vals, longitude_vals)

print(f'Best c: {best_c}')
print(f'Best e1: {best_e1}')
print(f'Best e2: {best_e2}')
print(f'Best z: {best_z}')
print(f'Best r: {best_r}')
print(f'Best s: {best_s}')
print(f'Angular Errors: {angular_errors}')
print(f'Maximum Angular Error: {max_angular_error}')

max_error_radians5 = max_angular_error * np.pi / 180
print(f'MaxError in radians: {max_error_radians5}')